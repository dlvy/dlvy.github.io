<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Avatar Generator with Stylish Filters</title>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
      Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    background: #0f172a;
    color: #fff;
    margin: 0;
    padding: 40px 0;
    display: flex;
    justify-content: center;
  }
  .container {
    background: #1e293b;
    padding: 20px;
    border-radius: 12px;
    width: 360px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  }
  h1 {
    font-size: 1.4rem;
    margin: 0 0 15px;
    text-align: center;
  }
  label {
    font-size: 0.9rem;
    margin-top: 10px;
    display: flex;
    flex-direction: column;
    gap: 5px;
  }
  input, button, select {
    padding: 8px;
    border-radius: 6px;
    border: none;
    font-size: 14px;
  }
  input[type=color] {
    padding: 0;
    height: 36px;
  }
  button {
    background: #6a11cb;
    color: white;
    cursor: pointer;
    transition: background 0.2s;
  }
  button:hover {
    background: #8331db;
  }
  .row {
    display: flex;
    gap: 10px;
    margin-top: 10px;
  }
  canvas {
    background: transparent;
    border-radius: 8px;
    display: block;
    margin: 15px auto 5px;
  }
  .note {
    font-size: 0.8rem;
    color: #94a3b8;
    text-align: center;
  }
</style>
</head>
<body>
<div class="container">
  <h1>Avatar Generator</h1>

  <canvas id="preview" width="256" height="256"></canvas>
  <p class="note">Preview (vector → raster, stays crisp)</p>

  <label>Emoji:
    <div class="row">
      <input id="emojiInput" type="text" value="😎" maxlength="4" autocomplete="off" spellcheck="false" />
      <button id="randomEmojiBtn" title="Random Emoji">🎲</button>
    </div>
      <div class="row">
        <span id="emojiChoices" style="display:flex;gap:4px;margin-left:8px;">
        <button class="emoji-choice" type="button">🗿</button>
        <button class="emoji-choice" type="button">📡</button>
        <button class="emoji-choice" type="button">🧬</button>
        <button class="emoji-choice" type="button">🐏</button>
        <button class="emoji-choice" type="button">🐱</button>
        <button class="emoji-choice" type="button">🦄</button>
        <button class="emoji-choice" type="button">🧞‍♂️</button>
        <button class="emoji-choice" type="button">🍄</button>
        <button class="emoji-choice" type="button">🦾</button>
        </span>
    </div>
    <div class="row">
      <span id="emojiChoices" style="display:flex;gap:4px;margin-left:8px;">
        <button class="emoji-choice" type="button">🔮</button>
        <button class="emoji-choice" type="button">💰</button>
        <button class="emoji-choice" type="button">📦</button>
        <button class="emoji-choice" type="button">💡</button>
        <button class="emoji-choice" type="button">🛡</button>
        <button class="emoji-choice" type="button">⚗️</button>
        <button class="emoji-choice" type="button">💎</button>
        <button class="emoji-choice" type="button">🩻</button>
        <button class="emoji-choice" type="button">🚏</button>
      </span>
      </div>
  </label>

  <label>Background Style:
    <select id="bgType">
      <option value="gradient">Gradient</option>
      <option value="tiles">Tiles</option>
      <option value="dots">Dots</option>
      <option value="stripes">Stripes</option>
    </select>
  </label>

  <label>Background Colors:
    <div class="row">
      <input id="c1" type="color" value="#ff7a18" />
      <input id="c2" type="color" value="#6a11cb" />
      <button id="randomGradientBtn" title="Random Gradient">🎨</button>
    </div>
  </label>

  <label>Gradient Type:
    <select id="gradType">
      <option value="linear">Linear</option>
      <option value="radial">Radial</option>
    </select>
  </label>

  <label>Filter:
    <select id="filterSelect">
      <option value="none">None</option>
      <option value="vaporwave">Vaporwave</option>
      <option value="colorswap">Color Swap</option>
      <option value="duotone">Duotone</option>
      <option value="glitch">Glitch</option>
      <option value="posterize">Posterize</option>
      <option value="neonglow">Neon Glow</option>
      <option value="invert">Invert</option>
      <option value="solarize">Solarize</option>
      <option value="outline">Outline</option>
    </select>
  </label>

  <label>Export Size (px):
    <input id="exportSize" type="number" value="200" min="32" max="4096" />
  </label>

  <div class="row" style="margin-top:15px;">
    <button id="exportBtn" style="flex:1;">Export PNG</button>
  </div>
</div>

<script>
const emojiList = ['😎','🤖','👩‍💻','🚀','🐱','🔥','🍕','🌈','🦄','🎮','📀','💾','🪐','📡','🐉','🎧'];

function emojiToFilename(emoji) {
  const codePoints = Array.from(emoji).map(ch => ch.codePointAt(0).toString(16));
  return `emoji_u${codePoints.join('_')}.svg`;
}

async function loadEmojiSVG(emoji) {
  const filename = emojiToFilename(emoji);
  const url = `https://raw.githubusercontent.com/googlefonts/noto-emoji/main/svg/${filename}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Failed to load emoji SVG: ${url}`);
  const svgText = await res.text();
  return 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgText)));
}

// Helper: clamp number between min and max
function clamp(num, min, max) {
  return num < min ? min : (num > max ? max : num);
}

// Helper: apply dithering - Floyd-Steinberg
function floydSteinbergDither(data, width, height, palette) {
  // data is Uint8ClampedArray [r,g,b,a,...]
  // palette: array of [r,g,b]

  function findClosestColor(r,g,b) {
    let minDist = Infinity;
    let best = palette[0];
    for (const c of palette) {
      const dr = r - c[0], dg = g - c[1], db = b - c[2];
      const dist = dr*dr + dg*dg + db*db;
      if (dist < minDist) {
        minDist = dist;
        best = c;
      }
    }
    return best;
  }

  for(let y=0; y<height; y++) {
    for(let x=0; x<width; x++) {
      const idx = (y*width + x)*4;
      const oldR = data[idx];
      const oldG = data[idx+1];
      const oldB = data[idx+2];
      const newColor = findClosestColor(oldR, oldG, oldB);
      data[idx] = newColor[0];
      data[idx+1] = newColor[1];
      data[idx+2] = newColor[2];

      const errR = oldR - newColor[0];
      const errG = oldG - newColor[1];
      const errB = oldB - newColor[2];

      function addError(dx, dy, factor) {
        const x1 = x + dx;
        const y1 = y + dy;
        if (x1 < 0 || x1 >= width || y1 < 0 || y1 >= height) return;
        const i1 = (y1*width + x1)*4;
        data[i1] = clamp(data[i1] + errR * factor, 0, 255);
        data[i1+1] = clamp(data[i1+1] + errG * factor, 0, 255);
        data[i1+2] = clamp(data[i1+2] + errB * factor, 0, 255);
      }

      addError(1, 0, 7/16);
      addError(-1, 1, 3/16);
      addError(0, 1, 5/16);
      addError(1, 1, 1/16);
    }
  }
}

// Filter implementations
function applyFilter(ctx, size, filter) {
  if (filter === 'none') return;

  const imageData = ctx.getImageData(0, 0, size, size);
  const data = imageData.data;

  if (filter === 'vaporwave') {
    function rgbToHsl(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h = 0, s = 0, l = (max + min) / 2;
      if (max !== min) {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      return [h, s, l];
    }
    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l * 255;
      } else {
        function hue2rgb(p, q, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        }
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3) * 255;
        g = hue2rgb(p, q, h) * 255;
        b = hue2rgb(p, q, h - 1/3) * 255;
      }
      return [r, g, b];
    }
    const hueShift = 0.75;
    for (let i = 0; i < data.length; i += 4) {
      let [h, s, l] = rgbToHsl(data[i], data[i + 1], data[i + 2]);
      h = (h + hueShift) % 1;
      s = Math.min(1, s * 1.4);
      l = Math.min(1, l * 1.1);
      const [r, g, b] = hslToRgb(h, s, l);
      data[i] = clamp(r, 0, 255);
      data[i + 1] = clamp(g, 0, 255);
      data[i + 2] = clamp(b, 0, 255);
    }
  }
  else if (filter === 'colorswap') {
    // Swap R/G/B channels for a surreal effect
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i], g = data[i+1], b = data[i+2];
      data[i] = g;
      data[i+1] = b;
      data[i+2] = r;
    }
  }
  else if (filter === 'duotone') {
    // Map to two colors: purple and yellow
    const cA = [128, 0, 255];
    const cB = [255, 220, 0];
    for (let i = 0; i < data.length; i += 4) {
      const avg = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
      const t = avg / 255;
      data[i] = Math.round(cA[0] * (1-t) + cB[0] * t);
      data[i+1] = Math.round(cA[1] * (1-t) + cB[1] * t);
      data[i+2] = Math.round(cA[2] * (1-t) + cB[2] * t);
    }
  }
  else if (filter === 'glitch') {
    // Pixel-level random offset for a noisy glitch effect
    const w = size, h = size;
    const copy = new Uint8ClampedArray(data);
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const idx = (y*w + x)*4;
        // Randomly offset pixel horizontally and vertically
        const dx = clamp(x + Math.floor((Math.random()-0.5)*4), 0, w-1);
        const dy = clamp(y + Math.floor((Math.random()-0.5)*2), 0, h-1);
        const srcIdx = (dy*w + dx)*4;
        data[idx] = copy[srcIdx];
        data[idx+1] = copy[srcIdx+1];
        data[idx+2] = copy[srcIdx+2];
      }
    }
  }
  else if (filter === 'posterize') {
    // Reduce color depth to 4 levels per channel
    for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.round(data[i] / 64) * 64;
      data[i+1] = Math.round(data[i+1] / 64) * 64;
      data[i+2] = Math.round(data[i+2] / 64) * 64;
    }
  }
  else if (filter === 'neonglow') {
    // Boost highlights and add glow
    for (let i = 0; i < data.length; i += 4) {
      let r = data[i], g = data[i+1], b = data[i+2];
      const avg = (r+g+b)/3;
      if (avg > 180) {
        r = clamp(r + 60, 0, 255);
        g = clamp(g + 60, 0, 255);
        b = clamp(b + 60, 0, 255);
      }
      // Add colored glow
      if (avg > 220) {
        r = clamp(r + 30, 0, 255);
        b = clamp(b + 30, 0, 255);
      }
      data[i] = r;
      data[i+1] = g;
      data[i+2] = b;
    }
  }
  else if (filter === 'invert') {
    // Invert colors
    for (let i = 0; i < data.length; i += 4) {
      data[i] = 255 - data[i];
      data[i+1] = 255 - data[i+1];
      data[i+2] = 255 - data[i+2];
    }
  }
  else if (filter === 'solarize') {
    // Solarize: invert colors above threshold
    for (let i = 0; i < data.length; i += 4) {
      for (let c = 0; c < 3; c++) {
        data[i+c] = data[i+c] > 128 ? 255-data[i+c] : data[i+c];
      }
    }
  }
  else if (filter === 'outline') {
    // Simple edge detection (Sobel)
    const w = size, h = size;
    const out = new Uint8ClampedArray(data.length);
    function getGray(i) {
      return 0.299*data[i]+0.587*data[i+1]+0.114*data[i+2];
    }
    for (let y = 1; y < h-1; y++) {
      for (let x = 1; x < w-1; x++) {
        const idx = (y*w + x)*4;
        const gx = getGray(idx-4) - getGray(idx+4);
        const gy = getGray(idx-w*4) - getGray(idx+w*4);
        let mag = Math.sqrt(gx*gx + gy*gy);
        mag = clamp(mag*2,0,255);
        out[idx] = out[idx+1] = out[idx+2] = mag;
        out[idx+3] = 255;
      }
    }
    for (let i = 0; i < data.length; i++) {
      data[i] = out[i];
    }
  }
  ctx.putImageData(imageData, 0, 0);
}

async function drawAvatar(ctx, size, emoji, c1, c2, gradType, filter) {
  // Draw creative backgrounds
  const bgType = document.getElementById('bgType')?.value || 'gradient';
  if (bgType === 'gradient') {
    let grad;
    if (gradType === 'radial') {
      grad = ctx.createRadialGradient(size/2, size/2, size*0.05, size/2, size/2, size*0.7);
    } else {
      grad = ctx.createLinearGradient(0, 0, size, size);
    }
    grad.addColorStop(0, c1);
    grad.addColorStop(1, c2);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, size, size);
  } else if (bgType === 'tiles') {
    // Draw a tile pattern
    ctx.fillStyle = c1;
    ctx.fillRect(0, 0, size, size);
    ctx.save();
    for (let y = 0; y < size; y += size/8) {
      for (let x = 0; x < size; x += size/8) {
        ctx.fillStyle = ((x+y)/(size/8))%2===0 ? c2 : '#fff2';
        ctx.fillRect(x, y, size/8, size/8);
      }
    }
    ctx.restore();
  } else if (bgType === 'dots') {
    // Draw a polka dot pattern
    ctx.fillStyle = c2;
    ctx.fillRect(0, 0, size, size);
    ctx.save();
    for (let y = size/12; y < size; y += size/6) {
      for (let x = size/12; x < size; x += size/6) {
        ctx.beginPath();
        ctx.arc(x, y, size/18, 0, 2*Math.PI);
        ctx.fillStyle = c1;
        ctx.globalAlpha = 0.7;
        ctx.fill();
      }
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  } else if (bgType === 'stripes') {
    // Draw diagonal stripes
    ctx.fillStyle = c2;
    ctx.fillRect(0, 0, size, size);
    ctx.save();
    ctx.rotate(-Math.PI/8);
    for (let i = -size; i < size*2; i += size/7) {
      ctx.beginPath();
      ctx.rect(i, 0, size/14, size*2);
      ctx.fillStyle = c1;
      ctx.globalAlpha = 0.5;
      ctx.fill();
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // Load emoji SVG image, fallback to text if fails
  let svgLoaded = false;
  let img;
  try {
    const imgSrc = await loadEmojiSVG(emoji);
    img = new Image();
    await new Promise((resolve, reject) => {
      img.onload = resolve;
      img.onerror = reject;
      img.src = imgSrc;
    });
    svgLoaded = true;
  } catch (e) {
    svgLoaded = false;
  }

  const padding = size * 0.1;
  if (svgLoaded) {
    ctx.drawImage(img, padding, padding, size - padding*2, size - padding*2);
  } else {
    // Fallback: render emoji as text
    ctx.save();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
  ctx.font = `bold ${size * 0.82}px sans-serif`;
    ctx.fillText(emoji, size/2, size/2);
    ctx.restore();
  }

  // Apply filter
  applyFilter(ctx, size, filter);
}

async function renderPreview() {
  const emoji = document.getElementById('emojiInput').value.trim() || '😎';
  const c1 = document.getElementById('c1').value;
  const c2 = document.getElementById('c2').value;
  const gradType = document.getElementById('gradType').value;
  const filter = document.getElementById('filterSelect').value;
  const bgType = document.getElementById('bgType')?.value || 'gradient';
  const canvas = document.getElementById('preview');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  try {
    await drawAvatar(ctx, canvas.width, emoji, c1, c2, gradType, filter, bgType);
  } catch(e) {
    console.error(e);
  }
}

async function exportPNG() {
  const emoji = document.getElementById('emojiInput').value.trim() || '😎';
  const c1 = document.getElementById('c1').value;
  const c2 = document.getElementById('c2').value;
  const gradType = document.getElementById('gradType').value;
  const filter = document.getElementById('filterSelect').value;
  const bgType = document.getElementById('bgType')?.value || 'gradient';
  let size = parseInt(document.getElementById('exportSize').value, 10);
  if(isNaN(size) || size < 32) size = 200;
  if(size > 4096) size = 4096;

  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  try {
    await drawAvatar(ctx, size, emoji, c1, c2, gradType, filter, bgType);
    canvas.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `avatar_${size}px.png`;
      a.click();
      URL.revokeObjectURL(url);
    });
  } catch(e) {
    alert("Failed to export: " + e.message);
  }
}

function randomEmoji() {
  document.getElementById('emojiInput').value = emojiList[Math.floor(Math.random()*emojiList.length)];
  renderPreview();
}
function randomGradient() {
  const randomColor = () => '#' + Math.floor(Math.random()*0xffffff).toString(16).padStart(6,'0');
  document.getElementById('c1').value = randomColor();
  document.getElementById('c2').value = randomColor();
  renderPreview();
}


['emojiInput','c1','c2','gradType','filterSelect','exportSize'].forEach(id => {
  document.getElementById(id).addEventListener('input', renderPreview);
});
document.getElementById('bgType').addEventListener('change', function() {
  const canvas = document.getElementById('preview');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  renderPreview();
});
document.getElementById('randomEmojiBtn').addEventListener('click', randomEmoji);
document.getElementById('randomGradientBtn').addEventListener('click', randomGradient);
document.getElementById('exportBtn').addEventListener('click', exportPNG);

// Emoji choices click handler
document.querySelectorAll('.emoji-choice').forEach(btn => {
  btn.addEventListener('click', function() {
    document.getElementById('emojiInput').value = this.textContent;
    renderPreview();
  });
});

renderPreview();
</script>
</body>
</html>

